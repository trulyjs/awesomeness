"use strict";exports.__esModule=!0,exports.default=exports.truly=exports.TrulyBase=void 0;function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}let Truly;function GetMethods(a){return Object.getOwnPropertyNames(a)}function copyUnique(a,b,c){void 0===c[a]&&(c[a]=b[a])}function LinkMethods(a,b){return a?(GetMethods(a.prototype).forEach(c=>copyUnique(c,a.prototype,b.prototype)),GetMethods(a).forEach(c=>copyUnique(c,a,b)),b):b}function generateTrulyMaker(){return LinkMethods(TrulyBase,function(a){this.construct(a)})}function flattenNested(a){return a instanceof Truly?flattenNested(a.then()):a}function executeExtension(a,b,c){if("isSupported"in a&&!a.isSupported(b)){const d=a=>JSON.stringify(a,null,"2");throw Error(`Truly extension "${a.name}" failed to support: 
                          subject: ${d(b)})
                          context: ${d(c)}
                          `)}return a.transform(b,c)}function register(a){if(!a.name)throw Error("Truly register requires a name");let b=Truly.prototype,c=a.name,d=!1!==a.chain;const e=GetMethods(b).includes(a.name)?b[a.name]:null,f=function(b){return e&&e.call(this,b,this.context),b=flattenNested(b),this.context=executeExtension(a,b,this.context),this};d&&(b[c]=f),a.tip&&(truly[c]=a=>f.call(new Truly,a))}function extend(a){Object.keys(a).forEach(b=>{const c=a[b];if(c.name)throw Error("Truly extend does not support name in extension body");c.name=b,register(c)})}class TrulyBase{constructor(){_defineProperty(this,"context",void 0)}construct(a){this.context=a}then(a){return"undefined"!=typeof a&&(this.context=this.context?a:null),this.context}}exports.TrulyBase=TrulyBase,_defineProperty(TrulyBase,"extend",extend),_defineProperty(TrulyBase,"register",register),Truly=generateTrulyMaker();const truly=function truly(a){return new Truly(a)};exports.truly=truly;var _default=Truly;exports.default=_default;